"use client";
import React, { useMemo, useEffect, useRef, useState } from "react";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
} from "recharts";
import { format, parseISO } from 'date-fns';
import * as d3 from 'd3';
import ethResearchData from '../data/eth_research_topic_scores_by_date.json';
import ethResearchViewsData from '../data/eth_research_topic_views_by_date.json';
import ethResearchParticipantsData from '../data/eth_research_topic_participant_count_by_date.json';
import leaderboardData from '../data/eth_research_leaderboard.json';

interface DataPoint {
  created_at: string;
  avg_score: number;
}

interface ViewsDataPoint {
  created_at: string;
  views: number;
}

interface ParticipantsDataPoint {
  created_at: string;
  participant_count: number;
}

interface LeaderboardItem {
  author_name: string;
  topic_count: number;
  reply_count: number;
  participant_count: number;
  avg_topic_score: number;
  like_count: number;
  view_count: number;
  weighted_score: number;
}

const ResearchPage: React.FC = () => {
  // Refs for the chart containers
  const scoreChartRef = useRef<HTMLDivElement>(null);
  const viewsChartRef = useRef<HTMLDivElement>(null);
  const participantsChartRef = useRef<HTMLDivElement>(null);
  const treemapRef = useRef<HTMLDivElement>(null);

  // State to store the HTML generated by D3
  const [treemapHtml, setTreemapHtml] = useState<string>("");

  // Prepare data for Recharts (no sorting)
  const data: DataPoint[] = useMemo(() => {
    return ethResearchData.map((item) => ({
      created_at: item.created_at,
      avg_score: item.avg_score
    }));
  }, []);

  // Prepare views data for Recharts
  const viewsData: ViewsDataPoint[] = useMemo(() => {
    return ethResearchViewsData.map((item) => ({
      created_at: item.created_at,
      views: item.views,
    }));
  }, []);

  // Prepare participants data for Recharts
  const participantsData: ParticipantsDataPoint[] = useMemo(() => {
    return ethResearchParticipantsData.map((item) => ({
      created_at: item.created_at,
      participant_count: item.participant_count,
    }));
  }, []);

  // Prepare leaderboard data
  const leaderboard: LeaderboardItem[] = useMemo(() => {
    return leaderboardData;
  }, []);

  const formatScore = (value: number) => value.toLocaleString('en-US', { maximumFractionDigits: 0 });
  const formatDate = (dateStr: string) => format(parseISO(dateStr), "MMM ''yy"); // Abbreviated format

  const minX = 0;
  const maxX = data.length - 1;
  const numTicks = 12; // Adjust the number of ticks as needed
  const tickIndices = useMemo(() => {
    const indices = [];
    const step = Math.max(Math.floor((maxX - minX) / (numTicks - 1)), 1); // Ensure step is at least 1
    for (let i = minX; i <= maxX; i += step) {
      indices.push(i);
    }
    if (indices[indices.length - 1] !== maxX) {
      indices[indices.length - 1] = maxX;
    }
    return indices;
  }, [minX, maxX, numTicks]);

  const formatTooltipDate = (dateStr: string) => format(parseISO(dateStr), "MMMM dd, সৌর");

  useEffect(() => {
    // Only run D3 code after initial client-side mount
    const container = d3.select(treemapRef.current);
    const containerWidth = container.node()?.getBoundingClientRect().width || 800;
    const height = 400;

    // Create the root node for the treemap
    type TreemapData = { children: LeaderboardItem[] };
    const root = d3.hierarchy<TreemapData>({ children: leaderboard });
    const treemapLayout = d3.treemap<TreemapData>()
      .size([containerWidth, height])
      .padding(2);

    // Sum and apply layout with type guard
    root.sum((d): number => {
      if ('weighted_score' in d && typeof d.weighted_score === 'number') {
        return d.weighted_score;
      }
      return 0;
    });
    treemapLayout(root);

    // Get the top 10 nodes for conditional label rendering
    const top10Nodes = root.leaves()
      .sort((a, b) => (b.value ?? 0) - (a.value ?? 0))
      .slice(0, 10);

    // Remove any existing treemap content before rendering
    container.selectAll("*").remove();

    // Append a group element for the entire treemap
    const svg = container
      .append("svg")
      .attr("width", containerWidth)
      .attr("height", height)
      .style("font", "10px sans-serif");

    // Render each node
    const leaf = svg
      .selectAll("g")
      .data(root.leaves() as d3.HierarchyRectangularNode<TreemapData>[])
      .join("g")
      .attr("transform", (d) => `translate(${d.x0},${d.y0})`);

    // Create rect elements and tooltips using native JS
    leaf.each(function (d) {
      const g = d3.select(this);
      const data = d.data as unknown as LeaderboardItem;
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      const colors = ["#444", "#555", "#666", "#777", "#888", "#999"];
      rect.setAttribute('fill', colors[d.depth % colors.length]);
      rect.setAttribute('width', (d.x1 - d.x0).toString());
      rect.setAttribute('height', (d.y1 - d.y0).toString());
      rect.setAttribute('rx', '3');
      rect.setAttribute('ry', '3');

      const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
      title.textContent = `Topics: ${data.topic_count}\nReplies: ${data.reply_count}\nParticipants: ${data.participant_count}\nAvg Topic Score: ${formatScore(data.avg_topic_score)}\nLikes: ${formatScore(data.like_count)}\nViews: ${formatScore(data.view_count)}`;
      rect.appendChild(title);

      const element = g.node() as SVGGElement;
      element.appendChild(rect);
    });

    // Add text labels for author names, conditionally based on top 10 and tile size
    leaf
      .append("text")
      .attr("text-anchor", "middle")
      .attr("x", (d) => (d.x1 - d.x0) / 2)
      .attr("y", (d) => (d.y1 - d.y0) / 2)
      .attr("fill", "#fff")
      .each(function (d) {
        const node = d3.select(this);
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        const data = (d.data as unknown as LeaderboardItem);

        // Check if the node is in the top 10 or if its area is above a certain threshold
        if (top10Nodes.includes(d) || width * height > 1000) {
          // Adjust threshold as needed
          // Determine font size based on the smaller dimension of the tile
          const maxFontSize = 18; // Maximum font size
          const minFontSize = 8; // Minimum font size
          const fontSize = Math.max(
            minFontSize,
            Math.min(maxFontSize, Math.min(width, height) / 5)
          ); // Adjust divisor to fine-tune size

          node.text(data.author_name).attr("font-size", `${fontSize}px`);
        } else {
          node.text(""); // Don't show text for smaller tiles
        }
      });

      // Update the state with the new HTML generated by D3
      setTreemapHtml(container.html() || "");
  }, [leaderboard]);

  return (
    <div className="p-6 bg-black text-white">
      <h1 className="text-2xl font-bold text-blue-500 mb-4">
        Top ethresear.ch Discourse Thread Metrics
      </h1>

      {/* Leaderboard Treemap */}
      <div className="mb-8">
        <h2 className="text-xl font-bold text-blue-500 mb-2">
          Ethereum Research Leaderboard
        </h2>
        {/* Use dangerouslySetInnerHTML to render the treemap HTML */}
        <div ref={treemapRef} dangerouslySetInnerHTML={{ __html: treemapHtml }} />
      </div>

      {/* Chart for Participants */}
      {participantsData.length > 0 && (
        <div className="mb-8" ref={participantsChartRef}>
          <h2 className="text-xl font-bold text-blue-500 mb-2">
            Top ethresear.ch Topic Participant Counts by Date
          </h2>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart
              data={participantsData}
              margin={{
                top: 40,
                right: 30,
                left: 60,
                bottom: 70,
              }}
            >
              <XAxis
                dataKey="created_at"
                tickFormatter={formatDate}
                label={{ value: "Thread Date", position: "insideBottom", dy: 55, fill: "white" }}
                stroke="white"
                interval={0}
                angle={-20}
                height={90}
                tick={{ dy: 5, fontSize: 14 }}
                ticks={tickIndices.map(i => data[i]?.created_at)}
              />
              <YAxis
                tickFormatter={formatScore}
                label={{ value: "Participant Count", angle: -90, position: "insideLeft", dx: -40, dy: 30, fill: "white" }}
                stroke="white"
                domain={['auto', 'dataMax + 100']}
              />
              <Tooltip
                contentStyle={{ backgroundColor: "#444", borderColor: "#888", color: 'white' }}
                labelFormatter={(value) => formatTooltipDate(value)}
                formatter={(value: number) => [formatScore(value), "Participants"]}
              />
              <Line
                type="monotone"
                dataKey="participant_count"
                stroke="#F27036"
                strokeWidth={2}
                dot={{ r: 1 }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      )}

      {/* Chart for Views */}
      {viewsData.length > 0 && (
        <div className="mb-8" ref={viewsChartRef}>
          <h2 className="text-xl font-bold text-blue-500 mb-2">
            Top ethresear.ch Topic Views by Date
          </h2>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart
              data={viewsData}
              margin={{
                top: 40,
                right: 30,
                left: 60,
                bottom: 70, // Increased bottom margin
              }}
            >
              <XAxis
                dataKey="created_at"
                tickFormatter={formatDate}
                label={{ value: "Thread Date", position: "insideBottom", dy: 55, fill: "white" }} // Further increase dy for label
                stroke="white"
                interval={0}
                angle={-20}
                height={90}
                tick={{ dy: 5, fontSize: 14 }} // Increase font size and adjust dy
                ticks={tickIndices.map(i => data[i]?.created_at)} // Use 'data' for consistency
              />
              <YAxis
                tickFormatter={formatScore}
                label={{ value: "Topic Views", angle: -90, position: "insideLeft", dx: -40, dy: 30, fill: "white" }}
                stroke="white"
                domain={['auto', 'dataMax + 1000']}
              />
              <Tooltip
                contentStyle={{ backgroundColor: "#444", borderColor: "#888", color: 'white' }}
                labelFormatter={(value) => formatTooltipDate(value)}
                formatter={(value: number) => [formatScore(value), "Views"]}
              />
              <Line
                type="monotone"
                dataKey="views"
                stroke="#82ca9d" // Different color for views
                strokeWidth={2}
                dot={{ r: 1 }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      )}

      {/* Chart for Scores */}
      {data.length > 0 && (
        <div className="mb-8" ref={scoreChartRef}>
          <h2 className="text-xl font-bold text-blue-500 mb-2">
            Top ethresear.ch Discourse Thread Scores Over Time
          </h2>
          <ResponsiveContainer width="100%" height={400}>
            <LineChart
              data={data}
              margin={{
                top: 40,     // Increase top margin
                right: 30,
                left: 60,    // Increase left margin 
                bottom: 70,   // Increase bottom margin to 60
              }}
            >
              <XAxis
                  dataKey="created_at"
                  tickFormatter={formatDate}
                  label={{ value: "Thread Date", position: "insideBottom", dy: 55, fill: "white" }} // Further increase dy for label
                  stroke="white"
                  interval={0}
                  angle={-20}
                  height={90}
                  tick={{ dy: 5, fontSize: 14 }} // Increase font size and adjust dy
                  ticks={tickIndices.map(i => data[i]?.created_at)}
              />
              <YAxis
                tickFormatter={formatScore}
                label={{ value: "Discourse Thread Score", angle: -90, position: "insideLeft", dx: -40, dy: 30, fill: "white" }}
                stroke="white"
                domain={['auto', 'dataMax + 1000']}
              />
              <Tooltip
                contentStyle={{ backgroundColor: "#444", borderColor: "#888", color: 'white' }}
                labelFormatter={(value) => formatTooltipDate(value)}
                formatter={(value: number) => [formatScore(value), "Score"]}
              />
              <Line
                type="monotone"
                dataKey="avg_score"
                stroke="#8884d8"
                strokeWidth={2}
                dot={{ r: 1 }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      )}
    </div>
  );
};

export default ResearchPage;